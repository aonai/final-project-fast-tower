#!/usr/bin/env python3
"""
This node is going to control the Baxter to grap a cup. 


SERVICES:
  + current_pose (Empty) ~ helper service for debugging. Will print out current pose of both grippers.
  + step (Step) ~ controls the grippers with given inputs.
"""

import rospy
import sys
import moveit_commander
from std_srvs.srv import Empty
from geometry_msgs.msg import Pose, Quaternion
from tower.srv import Step
from tf_conversions import transformations
from baxter_interface import Gripper


class Handler:
    """ Helper class for node control_arm.
    Setup moveit for Baxter.
    """
    def __init__(self):
        self.robot = moveit_commander.RobotCommander(robot_description='robot_description')
        self.scene = moveit_commander.PlanningSceneInterface()
        # 7 DOF
        self.both_arms_group = moveit_commander.MoveGroupCommander("both_arms", robot_description='robot_description')
        # self.left_arm_group = moveit_commander.MoveGroupCommander("left_arm", robot_description='robot_description')
        self.left_hand_group = moveit_commander.MoveGroupCommander("left_hand", robot_description='robot_description')
        # self.right_arm_group = moveit_commander.MoveGroupCommander("right_arm", robot_description='robot_description')
        self.right_hand_group = moveit_commander.MoveGroupCommander("right_hand", robot_description='robot_description')
        self.right_gripper = Gripper('right')
        self.right_gripper.calibrate()
        self.left_gripper = Gripper('left')
        self.left_gripper.calibrate()

        # self.test_arm()
        # self.test_both_arms()

        self.step = rospy.Service("step", Step, self.step_callback)
        self.current_pose = rospy.Service("current_pose", Empty, self.current_pose_callback)

    def current_pose_callback(self, req):
        """ helper service for debugging current pose of gripper"""
        current = self.both_arms_group.get_current_pose(end_effector_link = "left_gripper")
        q = current.pose.orientation
        angles = transformations.euler_from_quaternion([q.x, q.y, q.z, q.w])
        rospy.loginfo(f"left Current = {current.pose} --- euler: {angles}")

        current = self.both_arms_group.get_current_pose(end_effector_link = "right_gripper")
        q = current.pose.orientation
        angles = transformations.euler_from_quaternion([q.x, q.y, q.z, q.w])
        rospy.loginfo(f"right Current = {current.pose} --- euler: {angles}")
        return[]

    def test_both_arms(self):
        self.both_arms_group.set_position_target([1, 0.5, 0.5], end_effector_link = "left_gripper")
        self.both_arms_group.go(wait=True)
        self.both_arms_group.stop()
        self.both_arms_group.clear_pose_targets()

        self.both_arms_group.set_position_target([1, -0.5, 0.5], end_effector_link = "right_gripper")
        self.both_arms_group.go(wait=True)
        self.both_arms_group.stop()
        self.both_arms_group.clear_pose_targets()


    def test_arm(self):
        current = self.left_arm_group.get_current_pose()
        rospy.loginfo(f"left Current = {current}")
        current = self.right_arm_group.get_current_pose()
        rospy.loginfo(f"right Current = {current}")

        self.left_arm_group.set_position_target([1, 0.5, 0.5])
        self.left_arm_group.go(wait=True)
        self.left_arm_group.stop()
        self.left_arm_group.clear_pose_targets()

        self.right_arm_group.set_position_target([1, -0.5, 0.5])
        self.right_arm_group.go(wait=True)
        self.right_arm_group.stop()
        self.right_arm_group.clear_pose_targets()

    def step_callback(self, req):
        """ Helper funciton for step service
        Cup is about 10 cm. Left arm should handle cup with y > 0, and right arm should handle cup with y < 0.
        Cup should be grabbed on its side (ie. euler angles = [pi/2., 0, 0]). 

        Args:
            req (Step) 
                req.open_gripper (bool) - determines whether the gripper should be open at give position
                req.choose_left
                req.x
                req.y
                req.z
                req.r
                req.p
                req.yaw

        Returns: 
            string  - "Error Code = <the error code returned by the moveit MoveGroupCommander>
        """
        # arms
        pose_goal = Pose()
        pose_goal.position.x = req.x
        pose_goal.position.y = req.y
        pose_goal.position.z = req.z

        q1 = transformations.quaternion_from_euler(req.r, req.p, req.yaw, 'ryxz')
        pose_goal.orientation = Quaternion(*q1)
        
        ee_link = "left_gripper" if req.choose_left else "right_gripper" 
        rospy.loginfo(f"Moving {ee_link}")
        self.both_arms_group.set_pose_target(pose_goal, end_effector_link = ee_link)
        (result, plan, frac, errCode) = self.both_arms_group.plan()
        result = self.both_arms_group.execute(plan, wait=True)
        self.both_arms_group.stop()
        self.both_arms_group.clear_pose_targets()

        # grippers
        if req.open_gripper and req.choose_left:
            self.left_gripper.open(block=True)
        elif req.open_gripper and not req.choose_left:
            self.right_gripper.open(block=True)
        elif not req.open_gripper and req.choose_left:
            self.left_gripper.close(block=True)
        elif not req.open_gripper and not req.choose_left:
            self.right_gripper.close(block=True)

        return f"Error Code = {errCode.val}"


def main():
    """ The main() function. """
    moveit_commander.roscpp_initialize(sys.argv)
    rospy.loginfo(sys.argv)
    rospy.init_node('control_arm')
    handler = Handler()
    rospy.spin()

if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass