#!/usr/bin/env python3
"""
This node is going to control the Baxter to grap a cup. 


SERVICES:
  + current_pose (Empty) ~ helper service for debugging. Will print out current pose of both grippers.
  + step (Step) ~ controls the grippers with given inputs.
"""

import rospy
import numpy as np
import sys
import moveit_commander
from std_srvs.srv import Empty
from geometry_msgs.msg import Pose, Quaternion,Point
from tower.srv import Step, ControlTest
from tf.transformations import*
from tf_conversions import transformations
from baxter_interface import Gripper
# from tf_conversions.transformations import quaternion_from_euler
from tower.simulator import Scene

class Handler:
    """ Helper class for node control_arm.
    Setup moveit for Baxter.
    """
    def __init__(self):
        self.START_JOINTS = [0.19, 1.04, -0.02, 0.49, -0.18, 0.03, -0.01, \
                             -0.27, 1.04, 0.03, 0.5, -0.08, 0.03, 0.03]
        self.HOME_JOINTS = [1.0,  -0.74, -1.28, 0.97, -0.18, 0.03, -0.01, \
                            -1.1, -0.74, 1.28, 0.97, -0.18, 0.03, 0.03] 
        self.PRE_GRASP_POS = [0.0, 0.0, 0.2]
        self.GRASP_POS = [0.05, 0.0, 0.02]
        self.robot = moveit_commander.RobotCommander(robot_description='robot_description')
        scene = moveit_commander.PlanningSceneInterface()
        # 14 DOF
        self.both_arms_group = moveit_commander.MoveGroupCommander("both_arms", robot_description='robot_description')
        self.left_arm_group = moveit_commander.MoveGroupCommander("left_arm", robot_description='robot_description')
        self.right_arm_group = moveit_commander.MoveGroupCommander("right_arm", robot_description='robot_description')
        self.right_gripper = Gripper('right')
        # self.right_gripper.calibrate()
        self.left_gripper = Gripper('left')
        # self.left_gripper.calibrate()

        self.step = rospy.Service("step", Step, self.step_callback)
        self.test_control = rospy.Service("test_control", ControlTest, self.test_control_callback)

        # create scene 
        self.myscene = Scene(scene)
        self.myscene.create_scene_one_cup()

        # attach object
        # rospy.logdebug("============ Available Planning Groups:", self.robot.get_group_names())
        # self.myscene.attach_cup("right_hand", self.robot)
        self.go_home_position()
        rospy.loginfo("SET UP READY")

    def go_start_position(self):
        """ go to START position for easier grasping """
        self.both_arms_group.set_joint_value_target(self.START_JOINTS)
        self.execute_path()

    def go_home_position(self):
        """ go to HOME position for easier grasping """
        target = self.START_JOINTS.copy()
        for i in range(6):
            target[i] = self.HOME_JOINTS[i]
            target[i+7] = self.HOME_JOINTS[i+7]
            if i == 1:
                target[0] = self.START_JOINTS[0]
                target[7] = self.START_JOINTS[7]
            self.both_arms_group.set_joint_value_target(target)
            self.execute_path()
        
        pose = self.both_arms_group.get_current_pose(end_effector_link = "left_gripper").pose
        pose = self.orientation_forward(pose)
        self.both_arms_group.set_pose_target(pose, end_effector_link = "left_gripper")
        self.execute_path()

        pose = self.both_arms_group.get_current_pose(end_effector_link = "right_gripper").pose
        pose = self.orientation_forward(pose)
        self.both_arms_group.set_pose_target(pose, end_effector_link = "right_gripper")
        self.execute_path()

    def pick_cup_one_hand_pre_grasp(self,name,hand):
        """ helper function for moving gripper to standoff position before grasping cup
            
            Args: 
                name(String) - name of cup
                hand(String) - name of gripper to use
        """
        if(hand=="left_gripper"):
            self.left_gripper.open(block=True)
        elif(hand=="right_gripper"):
            self.right_gripper.open(block=True)

        pose_goal = self.myscene.get_cup_position(name)
        pose_goal = self.orientation_forward(pose_goal)
        pose_goal.position.x+=self.PRE_GRASP_POS[0]
        pose_goal.position.y+=self.PRE_GRASP_POS[1]
        pose_goal.position.z+=self.PRE_GRASP_POS[2]
        # rospy.logdebug(pose_goal)

        self.both_arms_group.set_pose_target(pose_goal, end_effector_link = hand)
        
    def pick_cup_one_hand_grasp(self,name,hand):
        """ helper function for grasping cup
            
            Args: 
                name(String) - name of cup
                hand(String) - name of gripper to use
        """
        pose_goal = self.myscene.get_cup_position(name)
        pose_goal = self.orientation_forward(pose_goal)
        pose_goal.position.x+=self.GRASP_POS[0]
        pose_goal.position.y+=self.GRASP_POS[1]
        pose_goal.position.z+=self.GRASP_POS[2]

        if hand=="right_gripper":
            plan, _ = self.right_arm_group.compute_cartesian_path([pose_goal],   # waypoints to follow
                                    0.001,        # eef_step
                                    0.0)         # jump_threshold
            # self.right_arm_group.set_max_velocity_scaling_factor(0.5)
            self.right_arm_group.execute(plan, wait=True)
            self.right_arm_group.stop()
            self.right_arm_group.clear_pose_targets()
            # self.right_arm_group.set_max_velocity_scaling_factor(1.0)

   
    def execute_path(self):
        """
        find plan for both hands & execute it 
        """
        rospy.logdebug("Executing plan")
        (result, plan, frac, errCode) = self.both_arms_group.plan()
        result = self.both_arms_group.execute(plan, wait=True)
        self.both_arms_group.stop()
        self.both_arms_group.clear_pose_target(end_effector_link = "left_gripper")
        self.both_arms_group.clear_pose_target(end_effector_link = "right_gripper")

    def orientation_forward(self,pose):
        """ helper function for setting the orientation forward at given pose """
        q = quaternion_from_euler(0, 1.5707,0)
        pose.orientation.x = q[0]
        pose.orientation.y = q[1]
        pose.orientation.z = q[2]
        pose.orientation.w = q[3]
        return pose

    def orientation_sideway(self,pose):
        """ helper function for setting the orientation sideway at given pose """
        q = quaternion_from_euler(1.5707, 0, 0)
        pose.orientation.x = q[0]
        pose.orientation.y = q[1]
        pose.orientation.z = q[2]
        pose.orientation.w = q[3]
        return pose

    def place_cup(self,pos,hand):
        pass

    def test_control_callback(self, req):
        """ helper service for testing other services or functions.
            Edit the inputs for service to test different cases.
            Args:
                req.choice - choose which test to execute
                            0. print current pose of left and right arm
                            1. test step service with left arm 
                            2. test step service with right arm 
                            3. set hands at home position
                            4. set hands at grasping position
                            5. set hand to grasp position
                            6. grab cups
                            7. restart scene
                            8. print current joint values
                            9. go to initial start position of robot 
        """
        if req.choice == 0: 
            result = self.current_pose()
            return result.replace('\n', ' ')
        elif req.choice == 8:
            result = self.current_joints()
            return result.replace('\n', ' ')
        elif req.choice == 9:
            self.go_start_position()
            return "go to start position"
        elif req.choice == 1:
            step_service = rospy.ServiceProxy("step", Step)
            result = step_service(open_gripper = False, choose_left = True, x=1.0, y=0.5, z=0.5, r=1.57, p=0.0, yaw=0.0)
            return result.output
        elif req.choice == 2:
            step_service = rospy.ServiceProxy("step", Step)
            result = step_service(open_gripper = True, choose_left = False, x=1.0, y=-0.5, z=0.5, r=1.57, p=0.0, yaw=0.0)
            return result.output
        elif req.choice == 3:
            self.go_home_position()
            return "go to home position"
        elif req.choice == 4:
            # rospy.logdebug("Setting goal for cup 1 ....")
            # self.pick_cup_one_hand_pre_grasp("Cup_1","left_gripper")
            rospy.logdebug("Setting goal  for cup 3 ....")
            self.pick_cup_one_hand_pre_grasp("Cup_3","right_gripper")
            rospy.logdebug("Executing pre-grasp")
            self.execute_path()
            return "before grasp cup_3"
        elif req.choice == 5:
            self.pick_cup_one_hand_grasp("Cup_3", "right_gripper")
            return "grasp cup_3"
        elif req.choice == 6:
             self.left_gripper.close(block=True)
             self.right_gripper.close(block=True)
             self.myscene.attach_cup("left_hand", self.robot,"Cup_1")
             self.myscene.attach_cup("right_hand", self.robot,"Cup_3")
        elif req.choice == 7:
            self.myscene.restart_scene()
        

        return "N/A"




    def state_1(self):
        """
        gets all cups from random locations and places them sorted at left/right side of the table
        For each arm 
        1 Assign a cup to grasp (left arm gets y>0 right arm gets y<0)
        2 Get position of cup
        3 Go to pregrasping position ( near the cup)
        4 Go to grasping position of cup
        5 Close gripper
        6 Attach cup at robot
        7 Get leaving cup position
        8 Go to leaving position
        9 Open gripper
        10 Detach cup from robot
        11 Go to Home position
        13 Repeat until all cups are sorted
        """
        # NEED TO HANDLE EXPECTION OF ONLY ONE CUP LEFT AND SECOND ARM HAS TO STAY NULL
        #go_home_position
        self.go_home_position()
        # Repeat until all cups are sorted
        while(not self.myscene.cups_sorted()):

            #Assign a cup to grasp (left arm gets y>0 right arm gets y<0)
            cap_nameL = self.myscene.assing_cup_st1("left_hand")
            cap_nameR = self.myscene.assing_cup_st1("right_hand")   

            #Get position of cup
            cap_posL = self.myscene.get_cup_position(cap_nameL)
            cap_posR = self.myscene.get_cup_position(cap_nameR)

            #Go to pregrasping position ( near the cup)
            self.pick_cup_one_hand_pre_grasp(cap_nameL,"left_gripper")
            self.pick_cup_one_hand_pre_grasp(cap_nameR,"right_gripper")
            self.execute_path()

            #Go to grasping position of cup
            self.pick_cup_one_hand_grasp(cap_nameL, "left_gripper")
            self.pick_cup_one_hand_grasp(cap_nameR, "right_gripper")
            self.execute_path()

            #Close gripper
            self.left_gripper.close(block=True)
            self.right_gripper.close(block=True)

            #Attach cup at robot
            self.myscene.attach_cup("left_hand", self.robot,cap_nameL)
            self.myscene.attach_cup("right_hand", self.robot,cap_nameR)

            #Get leaving cup position
            cap_posL =self.myscene.get_next_sorting_position("left_hand")
            cap_posR =self.myscene.get_next_sorting_position("right_hand")

            #Go to leaving position
            self.place_cup(cap_posL,"left_gripper")
            self.place_cup(cap_posR,"right_gripper")

            #Open gripper
            self.left_gripper.open(block=True)
            self.right_gripper.open(block=True)

            # Detach cup from robot
            self.myscene.detach_box(cap_nameL)
            self.myscene.detach_box(cap_nameR)

            # Go to Home position
            self.go_home_position()



    def state_2(self):
        """
        from a sorted cup enviroment 
        BUILDS A CUP TOWER !
        """
        pass




    def current_pose(self):
        """ helper function for debugging current pose of gripper """
        left_current = self.both_arms_group.get_current_pose(end_effector_link = "left_gripper")
        q = left_current.pose.orientation
        left_angles = transformations.euler_from_quaternion([q.x, q.y, q.z, q.w])

        right_current = self.both_arms_group.get_current_pose(end_effector_link = "right_gripper")
        q = left_current.pose.orientation
        right_angles = transformations.euler_from_quaternion([q.x, q.y, q.z, q.w])
        return f"left pos = {left_current.pose.position}, left euler = {left_angles}; right pos = {right_current.pose.position}, right euler = {right_angles}"
        
    def current_joints(self):
        """ helper function for debugging current joint of gripper """
        current = self.both_arms_group.get_current_joint_values()
        return f"joints = {np.round(current,2)}"

    def step_callback(self, req):
        """ Helper funciton for step service
        Cup is about 10 cm. Left arm should handle cup with y > 0, and right arm should handle cup with y < 0.
        Cup should be grabbed on its side (ie. euler angles = [pi/2., 0, 0]). 

        Args:
            req (Step) 
                req.open_gripper (bool) - determines whether the gripper should be open at give position
                req.choose_left
                req.x
                req.y
                req.z
                req.r
                req.p
                req.yaw

        Returns: 
            string  - "Error Code = <the error code returned by the moveit MoveGroupCommander>
        """
        # arms
        pose_goal = Pose()
        pose_goal.position.x = req.x
        pose_goal.position.y = req.y
        pose_goal.position.z = req.z

        q1 = transformations.quaternion_from_euler(req.r, req.p, req.yaw, 'ryxz')
        pose_goal.orientation = Quaternion(*q1)
        
        ee_link = "left_gripper" if req.choose_left else "right_gripper" 
        rospy.loginfo(f"Moving {ee_link}")
        self.both_arms_group.set_pose_target(pose_goal, end_effector_link = ee_link)
        (result, plan, frac, errCode) = self.both_arms_group.plan()

        result = self.both_arms_group.execute(plan, wait=True)
        self.both_arms_group.stop()
        self.both_arms_group.clear_pose_target(end_effector_link = ee_link)

        # grippers
        if req.open_gripper and req.choose_left:
            self.left_gripper.open(block=True)
        elif req.open_gripper and not req.choose_left:
            self.right_gripper.open(block=True)
        elif not req.open_gripper and req.choose_left:
            self.left_gripper.close(block=True)
        elif not req.open_gripper and not req.choose_left:
            self.right_gripper.close(block=True)

        return f"Error Code = {errCode.val}"


def main():
    """ The main() function. """
    moveit_commander.roscpp_initialize(sys.argv)
    rospy.loginfo(sys.argv)
    rospy.init_node('control_arm',log_level=rospy.DEBUG)
    handler = Handler()
    rospy.spin()

if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass