#!/usr/bin/env python3
"""
This node is going to control the Baxter to grap a cup. 


SERVICES:
  + current_pose (Empty) ~ helper service for debugging. Will print out current pose of both grippers.
  + step (Step) ~ controls the grippers with given inputs.
"""

import rospy
import sys
import moveit_commander
from std_srvs.srv import Empty
from geometry_msgs.msg import Pose, Quaternion
from tower.srv import Step, ControlTest
from tf.transformations import*
from tf_conversions import transformations
from baxter_interface import Gripper
# from tf_conversions.transformations import quaternion_from_euler
from tower.simulator import Scene

class Handler:
    """ Helper class for node control_arm.
    Setup moveit for Baxter.
    """
    def __init__(self):
        self.robot = moveit_commander.RobotCommander(robot_description='robot_description')
        scene = moveit_commander.PlanningSceneInterface()
        # 7 DOF
        self.both_arms_group = moveit_commander.MoveGroupCommander("both_arms", robot_description='robot_description')
        # self.left_arm_group = moveit_commander.MoveGroupCommander("left_arm", robot_description='robot_description')
        # self.left_hand_group = moveit_commander.MoveGroupCommander("left_hand", robot_description='robot_description')
        # self.right_arm_group = moveit_commander.MoveGroupCommander("right_arm", robot_description='robot_description')
        # self.right_hand_group = moveit_commander.MoveGroupCommander("right_hand", robot_description='robot_description')
        self.right_gripper = Gripper('right')
        # self.right_gripper.calibrate()
        self.left_gripper = Gripper('left')
        # self.left_gripper.calibrate()
        rospy.loginfo("SET UP READY")

        # self.test_arm()
        # self.test_both_arms()

        self.step = rospy.Service("step", Step, self.step_callback)
        self.test_control = rospy.Service("test_control", ControlTest, self.test_control_callback)

        # create scene 
        self.myscene = Scene(scene)
        self.myscene.create_scene_one_cup()

        # attach object
        group_names = self.robot.get_group_names()
        print("============ Available Planning Groups:", self.robot.get_group_names())
        
        self.myscene.attach_cup("right_hand", self.robot)
    
        

    def pick_cup_one_hand(self,name,hand):
        
        if(hand=="left_gripper"):
            self.left_gripper.open(block=True)
        elif(hand=="right_gripper"):
            self.right_gripper.open(block=True)

        pose_goal = self.myscene.get_cup_position(name)
        pose_goal = self.orientation_forward(pose_goal)

        # self.both_arms_group.set_pose_target(pose_goal, end_effector_link = hand)
        # (result, plan, frac, errCode) = self.both_arms_group.plan()
        # result = self.both_arms_group.execute(plan, wait=True)
        # self.both_arms_group.stop()
        # self.both_arms_group.clear_pose_target(end_effector_link = hand)


    def pick_cup_two_hands(self,name1,name2):
        #open grippers
        self.left_gripper.open(block=True)
        self.right_gripper.open(block=True)

        #get eef possition
        pose_goal1 = self.myscene.get_cup_position(name1)
        pose_goal1 = self.orientation_forward(pose_goal1)

        pose_goal2 = self.myscene.get_cup_position(name2)
        pose_goal2 = self.orientation_forward(pose_goal2)

        #set eef possition
        self.both_arms_group.set_pose_target(pose_goal1, end_effector_link = "left_gripper")
        self.both_arms_group.set_pose_target(pose_goal2, end_effector_link = "right_gripper")


    def execute_path(self):
        #execute 
        (result, plan, frac, errCode) = self.both_arms_group.plan()
        result = self.both_arms_group.execute(plan, wait=True)
        self.both_arms_group.stop()
        self.both_arms_group.clear_pose_target(end_effector_link = "left_gripper")
        self.both_arms_group.clear_pose_target(end_effector_link = "right_gripper")

    def orientation_forward(self,pose):
        q = quaternion_from_euler(0, 1.5707,0)
        pose.position.z +=0.2
        pose.orientation.x = q[0]
        pose.orientation.y = q[1]
        pose.orientation.z = q[2]
        pose.orientation.w = q[3]
        return pose

    def place_cup(self):
        pass

    def test_control_callback(self, req):
        """ helper service for testing other services or functions.
            Edit the inputs for service to test different cases.
            Args:
                req.choice - choose which test to execute
                            0. print current pose of left and right arm
                            1. test step service with left arm 
                            2. test step service with right arm 
        """
        if req.choice == 0: 
            result = self.current_pose()
            return result.replace('\n', ' ')
        elif req.choice == 1:
            step_service = rospy.ServiceProxy("step", Step)
            result = step_service(open_gripper = False, choose_left = True, x=1.0, y=0.5, z=0.5, r=1.57, p=0.0, yaw=0.0)
            return result.output
        elif req.choice == 2:
            step_service = rospy.ServiceProxy("step", Step)
            result = step_service(open_gripper = True, choose_left = False, x=1.0, y=-0.5, z=0.5, r=1.57, p=0.0, yaw=0.0)
            return result.output
        elif req.choice == 3:
            self.pick_cup_one_hand("Cup_1","left_gripper")
            self.execute_path()
        elif req.choice == 4:
            self.pick_cup_one_hand("Cup_1","left_gripper")
            self.pick_cup_one_hand("Cup_3","right_gripper")
            self.execute_path()


        return "N/A"

    def current_pose(self):
        """ helper service for debugging current pose of gripper"""
        left_current = self.both_arms_group.get_current_pose(end_effector_link = "left_gripper")
        q = left_current.pose.orientation
        left_angles = transformations.euler_from_quaternion([q.x, q.y, q.z, q.w])

        right_current = self.both_arms_group.get_current_pose(end_effector_link = "right_gripper")
        q = left_current.pose.orientation
        right_angles = transformations.euler_from_quaternion([q.x, q.y, q.z, q.w])
        return f"left pos = {left_current.pose.position}, left euler = {left_angles}; right pos = {right_current.pose.position}, right euler = {right_angles}"
    
    """
    def test_both_arms(self):
        self.both_arms_group.set_position_target([1, 0.5, 0.5], end_effector_link = "left_gripper")
        self.both_arms_group.go(wait=True)
        self.both_arms_group.stop()
        self.both_arms_group.clear_pose_targets()

        self.both_arms_group.set_position_target([1, -0.5, 0.5], end_effector_link = "right_gripper")
        self.both_arms_group.go(wait=True)
        self.both_arms_group.stop()
        self.both_arms_group.clear_pose_targets()
    """

    """
    def test_arm(self):
        current = self.left_arm_group.get_current_pose()
        rospy.loginfo(f"left Current = {current}")
        current = self.right_arm_group.get_current_pose()
        rospy.loginfo(f"right Current = {current}")

        self.left_arm_group.set_position_target([1, 0.5, 0.5])
        self.left_arm_group.go(wait=True)
        self.left_arm_group.stop()
        self.left_arm_group.clear_pose_targets()

        self.right_arm_group.set_position_target([1, -0.5, 0.5])
        self.right_arm_group.go(wait=True)
        self.right_arm_group.stop()
        self.right_arm_group.clear_pose_targets()
    """

    def step_callback(self, req):
        """ Helper funciton for step service
        Cup is about 10 cm. Left arm should handle cup with y > 0, and right arm should handle cup with y < 0.
        Cup should be grabbed on its side (ie. euler angles = [pi/2., 0, 0]). 

        Args:
            req (Step) 
                req.open_gripper (bool) - determines whether the gripper should be open at give position
                req.choose_left
                req.x
                req.y
                req.z
                req.r
                req.p
                req.yaw

        Returns: 
            string  - "Error Code = <the error code returned by the moveit MoveGroupCommander>
        """
        # arms
        pose_goal = Pose()
        pose_goal.position.x = req.x
        pose_goal.position.y = req.y
        pose_goal.position.z = req.z

        q1 = transformations.quaternion_from_euler(req.r, req.p, req.yaw, 'ryxz')
        pose_goal.orientation = Quaternion(*q1)
        
        ee_link = "left_gripper" if req.choose_left else "right_gripper" 
        rospy.loginfo(f"Moving {ee_link}")
        self.both_arms_group.set_pose_target(pose_goal, end_effector_link = ee_link)
        (result, plan, frac, errCode) = self.both_arms_group.plan()

        result = self.both_arms_group.execute(plan, wait=True)
        self.both_arms_group.stop()
        self.both_arms_group.clear_pose_target(end_effector_link = ee_link)

        # grippers
        if req.open_gripper and req.choose_left:
            self.left_gripper.open(block=True)
        elif req.open_gripper and not req.choose_left:
            self.right_gripper.open(block=True)
        elif not req.open_gripper and req.choose_left:
            self.left_gripper.close(block=True)
        elif not req.open_gripper and not req.choose_left:
            self.right_gripper.close(block=True)

        return f"Error Code = {errCode.val}"


def main():
    """ The main() function. """
    moveit_commander.roscpp_initialize(sys.argv)
    rospy.loginfo(sys.argv)
    rospy.init_node('control_arm')
    handler = Handler()
    rospy.spin()

if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass